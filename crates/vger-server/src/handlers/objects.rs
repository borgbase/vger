use std::sync::atomic::{AtomicU64, Ordering::Relaxed};

use axum::body::Body;
use axum::extract::{Path, Query, State};
use axum::http::{HeaderMap, StatusCode};
use axum::response::{IntoResponse, Response};
use futures_util::TryStreamExt;
use tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt, BufWriter, SeekFrom};
use tokio_util::io::{ReaderStream, StreamReader};

use crate::error::ServerError;
use crate::state::AppState;

static TEMP_COUNTER: AtomicU64 = AtomicU64::new(0);

#[derive(serde::Deserialize, Default)]
pub struct ObjectQuery {
    pub list: Option<String>,
    pub mkdir: Option<String>,
}

/// GET /{repo}/{*path} — if ?list present, list keys; otherwise read object.
/// Supports Range header for partial reads.
pub async fn get_or_list(
    State(state): State<AppState>,
    Path((repo, key)): Path<(String, String)>,
    Query(query): Query<ObjectQuery>,
    headers: HeaderMap,
) -> Result<Response, ServerError> {
    if query.list.is_some() {
        return list_keys(state, &repo, &key).await;
    }

    let file_path = state
        .file_path(&repo, &key)
        .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;

    // Check for Range header
    if let Some(range_header) = headers.get("Range").and_then(|v| v.to_str().ok()) {
        return handle_range_read(&file_path, range_header, &key).await;
    }

    stream_full_read(&file_path, &key).await
}

/// HEAD /{repo}/{*path} — check existence, return Content-Length.
pub async fn head_object(
    State(state): State<AppState>,
    Path((repo, key)): Path<(String, String)>,
) -> Result<Response, ServerError> {
    let file_path = state
        .file_path(&repo, &key)
        .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;

    let meta = match tokio::fs::metadata(&file_path).await {
        Ok(m) => m,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Ok(StatusCode::NOT_FOUND.into_response());
        }
        Err(e) => return Err(ServerError::from(e)),
    };

    Ok((
        StatusCode::OK,
        [("Content-Length", meta.len().to_string())],
        Body::empty(),
    )
        .into_response())
}

/// PUT /{repo}/{*path} — write object. Enforces append-only and quota.
///
/// Streams the request body to a temp file to avoid buffering large uploads
/// in memory. Atomic rename on completion.
pub async fn put_object(
    State(state): State<AppState>,
    Path((repo, key)): Path<(String, String)>,
    headers: HeaderMap,
    body: axum::body::Body,
) -> Result<Response, ServerError> {
    let file_path = state
        .file_path(&repo, &key)
        .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;

    let existing_meta = match tokio::fs::metadata(&file_path).await {
        Ok(meta) => Some(meta),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => None,
        Err(e) => return Err(ServerError::from(e)),
    };

    // Append-only: reject overwrites of pack files
    if state.inner.config.append_only && key.starts_with("packs/") && existing_meta.is_some() {
        return Err(ServerError::Forbidden(
            "append-only: cannot overwrite pack files".into(),
        ));
    }

    // Track old file size for quota accounting
    let old_size = existing_meta.as_ref().map_or(0, |m| m.len());

    // Quota pre-check using Content-Length if available
    let quota = state.inner.config.quota_bytes;
    if quota > 0 {
        if let Some(content_length) = headers
            .get("Content-Length")
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.parse::<u64>().ok())
        {
            let used = state.quota_used(&repo);
            if used.saturating_sub(old_size) + content_length > quota {
                return Err(ServerError::PayloadTooLarge(format!(
                    "quota exceeded: used {used}, limit {quota}, request {content_length}",
                )));
            }
        }
    }

    // Ensure parent directory exists
    if let Some(parent) = file_path.parent() {
        tokio::fs::create_dir_all(parent)
            .await
            .map_err(ServerError::from)?;
    }

    // Generate a unique temp file name
    let unique_id = TEMP_COUNTER.fetch_add(1, Relaxed);
    let file_name = file_path
        .file_name()
        .unwrap_or_default()
        .to_string_lossy();
    let temp_path = file_path.with_file_name(format!(".tmp.{file_name}.{unique_id}"));

    // Stream body to temp file. The write block scopes writer/reader so
    // file handles are closed before rename (required on Windows).
    let data_len = {
        let stream = body.into_data_stream();
        let stream = TryStreamExt::map_err(stream, std::io::Error::other);
        let mut reader = StreamReader::new(stream);

        let temp_file = tokio::fs::File::create(&temp_path)
            .await
            .map_err(ServerError::from)?;
        let mut writer = BufWriter::new(temp_file);

        let mut data_len: u64 = 0;
        let mut buf = vec![0u8; 256 * 1024]; // 256 KiB read buffer
        let write_result: Result<(), ServerError> = async {
            loop {
                let n = reader.read(&mut buf).await.map_err(ServerError::from)?;
                if n == 0 {
                    break;
                }

                data_len += n as u64;

                // Per-chunk quota enforcement
                if quota > 0 {
                    let used = state.quota_used(&repo);
                    if used.saturating_sub(old_size) + data_len > quota {
                        return Err(ServerError::PayloadTooLarge(format!(
                            "quota exceeded during upload: used {used}, limit {quota}, written {data_len}",
                        )));
                    }
                }

                writer.write_all(&buf[..n]).await.map_err(ServerError::from)?;
            }
            writer.flush().await.map_err(ServerError::from)?;
            Ok(())
        }
        .await;

        // Drop writer (closes file handle) before any cleanup or rename
        drop(writer);

        if let Err(e) = write_result {
            let _ = tokio::fs::remove_file(&temp_path).await;
            return Err(e);
        }

        data_len
    };

    // Atomic rename temp → final path (file handle already closed)
    if let Err(e) = tokio::fs::rename(&temp_path, &file_path).await {
        let _ = tokio::fs::remove_file(&temp_path).await;
        return Err(ServerError::from(e));
    }

    // Update quota
    if data_len > old_size {
        state.add_quota_usage(&repo, data_len - old_size);
    } else {
        state.sub_quota_usage(&repo, old_size - data_len);
    }

    // Detect manifest write → record backup timestamp
    if key == "manifest" {
        state.record_backup(&repo);
    }

    let status = if old_size > 0 {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::CREATED
    };
    Ok(status.into_response())
}

/// DELETE /{repo}/{*path} — delete object. Rejected in append-only mode.
pub async fn delete_object(
    State(state): State<AppState>,
    Path((repo, key)): Path<(String, String)>,
) -> Result<Response, ServerError> {
    if state.inner.config.append_only {
        return Err(ServerError::Forbidden(
            "append-only: delete not allowed".into(),
        ));
    }

    let file_path = state
        .file_path(&repo, &key)
        .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;

    let old_size = match tokio::fs::metadata(&file_path).await {
        Ok(meta) => meta.len(),
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Ok(StatusCode::NOT_FOUND.into_response());
        }
        Err(e) => return Err(ServerError::from(e)),
    };

    match tokio::fs::remove_file(&file_path).await {
        Ok(()) => {
            state.sub_quota_usage(&repo, old_size);
            Ok(StatusCode::NO_CONTENT.into_response())
        }
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            Ok(StatusCode::NOT_FOUND.into_response())
        }
        Err(e) => Err(ServerError::from(e)),
    }
}

async fn stream_full_read(file_path: &std::path::Path, key: &str) -> Result<Response, ServerError> {
    let file = match tokio::fs::File::open(file_path).await {
        Ok(file) => file,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Err(ServerError::NotFound(key.to_string()));
        }
        Err(e) => return Err(ServerError::from(e)),
    };

    let file_len = file.metadata().await.map_err(ServerError::from)?.len();
    let body = Body::from_stream(ReaderStream::new(file));
    Ok((
        StatusCode::OK,
        [("Content-Length", file_len.to_string())],
        body,
    )
        .into_response())
}

/// POST /{repo}/{*path}?mkdir — create directory.
pub async fn post_object(
    State(state): State<AppState>,
    Path((repo, key)): Path<(String, String)>,
    Query(query): Query<ObjectQuery>,
) -> Result<Response, ServerError> {
    if query.mkdir.is_some() {
        let dir_path = state
            .file_path(&repo, &key)
            .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;
        tokio::fs::create_dir_all(&dir_path)
            .await
            .map_err(ServerError::from)?;
        return Ok(StatusCode::CREATED.into_response());
    }

    Ok(StatusCode::BAD_REQUEST.into_response())
}

async fn list_keys(state: AppState, repo: &str, prefix: &str) -> Result<Response, ServerError> {
    let dir_path = state
        .file_path(repo, prefix)
        .ok_or_else(|| ServerError::BadRequest("invalid path".into()))?;

    let prefix_owned = prefix.to_string();
    let keys = tokio::task::spawn_blocking(move || list_files_recursive(&dir_path, &prefix_owned))
        .await
        .map_err(|e| ServerError::Internal(e.to_string()))?;

    Ok(axum::Json(keys).into_response())
}

fn list_files_recursive(dir: &std::path::Path, prefix: &str) -> Vec<String> {
    let mut keys = Vec::new();
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            let name = entry.file_name().to_string_lossy().to_string();
            let full_key = if prefix.is_empty() {
                name.clone()
            } else {
                format!("{}/{}", prefix.trim_end_matches('/'), name)
            };
            if path.is_dir() {
                keys.extend(list_files_recursive(&path, &full_key));
            } else {
                keys.push(full_key);
            }
        }
    }
    keys
}

/// PUT without Content-Length header (for concurrent test).
#[cfg(test)]
pub(crate) async fn authed_put_no_cl(
    router: axum::Router,
    path: &str,
    body: Vec<u8>,
) -> axum::response::Response {
    use tower::ServiceExt;
    let req = axum::http::Request::builder()
        .method("PUT")
        .uri(path)
        .header(
            "Authorization",
            format!("Bearer {}", super::test_helpers::TEST_TOKEN),
        )
        .body(Body::from(body))
        .unwrap();
    router.oneshot(req).await.unwrap()
}

async fn handle_range_read(
    file_path: &std::path::Path,
    range_header: &str,
    key: &str,
) -> Result<Response, ServerError> {
    // Parse "bytes=<start>-<end>"
    let range_str = range_header
        .strip_prefix("bytes=")
        .ok_or_else(|| ServerError::BadRequest("invalid Range header".into()))?;

    let parts: Vec<&str> = range_str.split('-').collect();
    if parts.len() != 2 {
        return Err(ServerError::BadRequest("invalid Range header".into()));
    }

    let start: u64 = parts[0]
        .parse()
        .map_err(|_| ServerError::BadRequest("invalid range start".into()))?;
    let end: u64 = parts[1]
        .parse()
        .map_err(|_| ServerError::BadRequest("invalid range end".into()))?;
    if end < start {
        return Err(ServerError::BadRequest(
            "invalid Range header: end before start".into(),
        ));
    }

    let length = end
        .checked_sub(start)
        .and_then(|d| d.checked_add(1))
        .ok_or_else(|| ServerError::BadRequest("invalid Range header".into()))?;
    let mut file = match tokio::fs::File::open(file_path).await {
        Ok(f) => f,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Err(ServerError::NotFound(key.to_string()));
        }
        Err(e) => return Err(ServerError::from(e)),
    };
    let file_len = file.metadata().await.map_err(ServerError::from)?.len();

    if start >= file_len {
        return Err(ServerError::from(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "range start beyond file size",
        )));
    }

    file.seek(SeekFrom::Start(start))
        .await
        .map_err(ServerError::from)?;

    let to_read_u64 = length.min(file_len - start);
    let actual_end = start + to_read_u64 - 1;
    let body = Body::from_stream(ReaderStream::new(file.take(to_read_u64)));

    Ok((
        StatusCode::PARTIAL_CONTENT,
        [
            (
                "Content-Range",
                format!("bytes {start}-{actual_end}/{file_len}"),
            ),
            ("Content-Length", to_read_u64.to_string()),
        ],
        body,
    )
        .into_response())
}

#[cfg(test)]
mod tests {
    use axum::http::StatusCode;

    use super::super::test_helpers::*;

    const CONFIG_PATH: &str = "/test-repo/config";

    #[tokio::test]
    async fn put_then_get_round_trip() {
        let (router, _state, _tmp) = setup_app(0);
        let data = vec![0xAB; 4096];

        let resp = authed_put(router.clone(), CONFIG_PATH, data.clone()).await;
        assert_status(&resp, StatusCode::CREATED);

        let resp = authed_get(router, CONFIG_PATH).await;
        assert_status(&resp, StatusCode::OK);
        assert_eq!(body_bytes(resp).await, data);
    }

    #[tokio::test]
    async fn put_overwrite_returns_no_content() {
        let (router, _state, _tmp) = setup_app(0);

        let resp = authed_put(router.clone(), CONFIG_PATH, vec![1; 100]).await;
        assert_status(&resp, StatusCode::CREATED);

        let resp = authed_put(router.clone(), CONFIG_PATH, vec![2; 200]).await;
        assert_status(&resp, StatusCode::NO_CONTENT);

        // Verify content was updated
        let resp = authed_get(router, CONFIG_PATH).await;
        assert_eq!(body_bytes(resp).await, vec![2u8; 200]);
    }

    #[tokio::test]
    async fn put_quota_rejected() {
        let (router, _state, _tmp) = setup_app(1024); // 1 KiB quota
        let data = vec![0xFF; 2048]; // 2 KiB body

        let resp = authed_put(router, CONFIG_PATH, data).await;
        assert_status(&resp, StatusCode::PAYLOAD_TOO_LARGE);
    }

    #[tokio::test]
    async fn put_overwrite_net_quota() {
        let (router, _state, _tmp) = setup_app(10 * 1024); // 10 KiB

        // Upload 8 KiB — should succeed
        let resp = authed_put(router.clone(), CONFIG_PATH, vec![0xAA; 8 * 1024]).await;
        assert_status(&resp, StatusCode::CREATED);

        // Overwrite with 4 KiB — should succeed, net usage drops to 4 KiB
        let resp = authed_put(router.clone(), CONFIG_PATH, vec![0xBB; 4 * 1024]).await;
        assert_status(&resp, StatusCode::NO_CONTENT);

        // Upload another 6 KiB to a different key — total would be 10 KiB, should succeed
        let resp = authed_put(router.clone(), "/test-repo/index", vec![0xCC; 6 * 1024]).await;
        assert_status(&resp, StatusCode::CREATED);

        // Verify first file has new content
        let resp = authed_get(router, CONFIG_PATH).await;
        assert_eq!(body_bytes(resp).await.len(), 4 * 1024);
    }

    #[tokio::test]
    async fn put_no_leftover_temp_files() {
        let (router, _state, tmp) = setup_app(0);

        let resp = authed_put(router, CONFIG_PATH, vec![0x42; 512]).await;
        assert_status(&resp, StatusCode::CREATED);

        // Check no .tmp.* files in the repo dir
        assert_no_temp_files(tmp.path());
    }

    #[tokio::test]
    async fn put_quota_rejection_cleans_temp() {
        let (router, _state, tmp) = setup_app(256);

        // Upload that will be rejected by Content-Length pre-check
        let resp = authed_put(router, CONFIG_PATH, vec![0xFF; 512]).await;
        assert_status(&resp, StatusCode::PAYLOAD_TOO_LARGE);

        assert_no_temp_files(tmp.path());
    }

    #[tokio::test]
    async fn put_concurrent_same_key() {
        let (router, _state, tmp) = setup_app(0);
        let data_a = vec![0xAA; 1024];
        let data_b = vec![0xBB; 1024];

        let router_a = router.clone();
        let router_b = router.clone();
        let da = data_a.clone();
        let db = data_b.clone();

        let (ra, rb) = tokio::join!(
            super::authed_put_no_cl(router_a, CONFIG_PATH, da),
            super::authed_put_no_cl(router_b, CONFIG_PATH, db),
        );

        // Both should succeed (one creates, one overwrites — or both create
        // depending on race). Accept CREATED or NO_CONTENT for either.
        assert!(
            ra.status() == StatusCode::CREATED || ra.status() == StatusCode::NO_CONTENT,
            "unexpected status A: {}",
            ra.status()
        );
        assert!(
            rb.status() == StatusCode::CREATED || rb.status() == StatusCode::NO_CONTENT,
            "unexpected status B: {}",
            rb.status()
        );

        // File content should match one of the two payloads
        let resp = authed_get(router, CONFIG_PATH).await;
        let body = body_bytes(resp).await;
        assert!(
            body == data_a || body == data_b,
            "file content doesn't match either payload"
        );

        // No orphan temp files
        assert_no_temp_files(tmp.path());
    }

    /// Recursively check that no `.tmp.*` files exist under the given path.
    fn assert_no_temp_files(dir: &std::path::Path) {
        for path in walk_file_paths(dir) {
            let name = path.file_name().unwrap().to_string_lossy();
            assert!(
                !name.starts_with(".tmp."),
                "leftover temp file: {}",
                path.display()
            );
        }
    }

    fn walk_file_paths(dir: &std::path::Path) -> Vec<std::path::PathBuf> {
        let mut out = Vec::new();
        if let Ok(entries) = std::fs::read_dir(dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    out.extend(walk_file_paths(&path));
                } else {
                    out.push(path);
                }
            }
        }
        out
    }
}
