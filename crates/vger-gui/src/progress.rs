use std::time::Instant;

use vger_core::commands::backup::BackupProgressEvent;
use vger_core::commands::check::CheckProgressEvent;

const THROTTLE_MS: u128 = 250;

pub fn format_bytes(bytes: u64) -> String {
    const KB: f64 = 1024.0;
    const MB: f64 = KB * 1024.0;
    const GB: f64 = MB * 1024.0;

    let b = bytes as f64;
    if b >= GB {
        format!("{:.2} GiB", b / GB)
    } else if b >= MB {
        format!("{:.2} MiB", b / MB)
    } else if b >= KB {
        format!("{:.2} KiB", b / KB)
    } else {
        format!("{bytes} B")
    }
}

fn truncate_middle(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        return s.to_string();
    }
    let keep = max_len.saturating_sub(3); // room for "..."
    let head = keep / 2;
    let tail = keep - head;
    format!("{}...{}", &s[..head], &s[s.len() - tail..])
}

pub fn format_count(n: u64) -> String {
    let s = n.to_string();
    let mut result = String::with_capacity(s.len() + s.len() / 3);
    for (i, c) in s.chars().enumerate() {
        if i > 0 && (s.len() - i).is_multiple_of(3) {
            result.push(',');
        }
        result.push(c);
    }
    result
}

pub struct BackupStatusTracker {
    repo_name: String,
    last_update: Instant,
}

impl BackupStatusTracker {
    pub fn new(repo_name: String) -> Self {
        Self {
            repo_name,
            last_update: Instant::now() - std::time::Duration::from_millis(THROTTLE_MS as u64),
        }
    }

    /// Returns Some(status_string) if enough time has elapsed or the event is significant.
    /// Returns None if the update should be skipped (throttled).
    pub fn format(&mut self, event: &BackupProgressEvent) -> Option<String> {
        match event {
            BackupProgressEvent::SourceStarted { source_path } => {
                self.last_update = Instant::now();
                Some(format!(
                    "[{}] backing up {}...",
                    self.repo_name, source_path
                ))
            }
            BackupProgressEvent::StatsUpdated {
                nfiles,
                original_size,
                current_file,
                ..
            } => {
                let now = Instant::now();
                if now.duration_since(self.last_update).as_millis() < THROTTLE_MS {
                    return None;
                }
                self.last_update = now;
                let file_suffix = match current_file {
                    Some(f) => format!(" - {}", truncate_middle(f, 60)),
                    None => String::new(),
                };
                Some(format!(
                    "[{}] {} files, {}{}",
                    self.repo_name,
                    format_count(*nfiles),
                    format_bytes(*original_size),
                    file_suffix,
                ))
            }
            _ => None,
        }
    }
}

pub fn format_check_status(repo_name: &str, event: &CheckProgressEvent) -> String {
    match event {
        CheckProgressEvent::SnapshotStarted {
            current,
            total,
            name,
        } => format!("[{repo_name}] checking snapshot {current}/{total}: {name}..."),
        CheckProgressEvent::PacksExistencePhaseStarted { total_packs } => {
            format!("[{repo_name}] verifying packs (0/{total_packs})...")
        }
        CheckProgressEvent::PacksExistenceProgress {
            checked,
            total_packs,
        } => format!("[{repo_name}] verifying packs ({checked}/{total_packs})..."),
        CheckProgressEvent::ChunksDataPhaseStarted { total_chunks } => {
            format!("[{repo_name}] verifying data (0/{total_chunks})...")
        }
        CheckProgressEvent::ChunksDataProgress {
            verified,
            total_chunks,
        } => format!("[{repo_name}] verifying data ({verified}/{total_chunks})..."),
        CheckProgressEvent::ServerVerifyPhaseStarted { total_packs } => {
            format!("[{repo_name}] verifying server packs (0/{total_packs})...")
        }
        CheckProgressEvent::ServerVerifyProgress {
            verified,
            total_packs,
        } => format!("[{repo_name}] verifying server packs ({verified}/{total_packs})..."),
    }
}
